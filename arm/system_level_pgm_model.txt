The system level programmers’ model includes all of the system features required
to support operating systems and to handle hardware events.

--------------------------------------------------------------------------------
Mode
--------------------------------------------------------------------------------
Determines:
• the set of registers that are available to the processor
• the privilege level of the executing software
USER			PL0		S/NS	unprivileged execution
FIQ				PL1		S/NS
IRQ				PL1		S/NS
SUPERVISOR		PL1		S/NS	svc/swi, default mode after reset
MONITOR			PL1		S		smc
ABORT			PL1		S/NS	data/prefetech abort
HYPERVISOR		PL2		NS		hvc
UNDEFINED		PL1		S/NS
SYSTEM			PL1		S/NS	not entered by any exception
--------------------------------------------------------------------------------
State
--------------------------------------------------------------------------------
# Instruction set state:
1) ARM state
2) Thumb state
3) Jazelle state
4) ThumbEE

# Execution state:
-> consists of following states which modify how stream is decoded:
1) instruction set state and 
2) some control bits: PSR

# Security state:
implementation includes Security Extensions provides two security states:
# Secure state and 
# Non-secure state

-> Each security state has its own system registers and memory address space

-> Monitor mode: 
exists only in the Secure state, and supports transitions between Secure and
Non-secure state.

-> Hyp mode:
part of the Virtualization Extensions, that exits only in the Non-secure state

*-> An implementation that does not include the Security Extensions provides
only a single security state.

-> It provides the usual method of controlling almost all of the functionality
of the Virtualization Extensions.

-> The alternative method of controlling this functionality is by accessing the
Hyp mode controls from Secure Monitor mode, with the SCR.NS bit set to 1.

-> in Secure state, the effect of attempting to set CPSR.M to 0b11010(HYP Mode)
is UNPREDICTABLE.

-> In Hyp mode, the only exception return is execution of an ERET instruction

-> If software running in Hyp mode executes an SVC instruction, the Supervisor
Call exception generated by the instruction is taken to Hyp mode.


# Debug state:
--------------------------------------------------------------------------------
Privilege level
--------------------------------------------------------------------------------
# Secure state
PL0: Software executed in User mode executes at PL0.
PL1: Software executed in any mode other than User mode executes at PL1

# Non Secure state
PL0: Software executed in User mode executes at PL0
PL1: Software executed in any mode other than User or Hyp mode executes at PL1
PL2: software executed in Hyp mode executes at PL2

--------------------------------------------------------------------------------
Exceptions
--------------------------------------------------------------------------------
# Synchronous
An exception is described as synchronous if both of the following apply:
-> the exception is generated as a result of execution of instruction stream
-> the return address presented to the exception handler is guaranteed to
indicate the instruction that caused the exception.
-> return to same mode the exception is taken from in which it was generated

# Asynchronous
-> the exception is not generated as a result of direct execution of instruction
stream
-> the return address presented to the exception handler is not guaranteed to
indicate the instruction that caused the exception.
-> for an asynchronous exception, the processor mode might change after the
exception is generated and before it is taken

-> Exceptions must be taken to a mode with a privilege level of PL1 or higher

-> Within a particular security state:
— an exception must be taken to a mode with a privilege level greater than or
equal to the privilege level of the mode the exception is taken from.
— exception return must be made to a mode with a privilege level less than or
equal to the privilege level at which the exception handler is executing.

-> In an implementation that includes the Security Extensions:
- An exception can be taken from any Non-secure mode, including Hyp mode, to
Secure Monitor mode.

- An exception can never be taken from a Secure mode to a Non-secure mode

--------------------------------------------------------------------------------
ARM Core registers
--------------------------------------------------------------------------------
-> The architecture uses system level register names, such as R0_usr, R8_usr,
and R8_fiq, when it must identify a specific register. 
-> The application level names refer to the registers for the current mode, and
usually are sufficient to identify a register.
-> The Security Extensions and Virtualization Extensions are supported only in
the ARMv7-A architecture profile.
-> The Virtualization Extensions require implementation of the Security
Extensions

-> Each mode of the processor has its own
-->banked copy of stack pointer: r13: SP_mode
which means each mode can have its own stack

-->banked copy of link register: r12: LR_mode except hyp mode.
ELR_hyp:
-------
---> Hyp mode does not provide its own Banked copy of LR. Instead, on taking an
exception to Hyp mode, the preferred return address is stored in ELR_hyp.

---> ELR_hyp is implemented only as part of the Virtualization Extensions.

---> can be accessed by MSR and MRS instruction

---> The ERET instruction uses the value in ELR_hyp as the return address for
the exception.

--> In addition FIQ mode has Banked copies of the ARM core registers R8 to R12

--> User mode and System mode share the same ARM core registers.

-> CPSR, APSR
Condition flags, bits[31:28]: 	Read/Write in any mode
Q, bit[27]: 					Read/Write in any mode
IT[7:0], bits[15:10, 26:25]:
J, bit[24]: 
Bits[23:20]: 					Reserved, RAZ/SBZP
GE[3:0], bits[19:16]: 			Read/Write in any mode
E, bit[9]:Endianess
Mask bits, bits[8:6]:			0: Masked, 1: not masked
A bit[8]:						Write only in PL1 or higher
I bit[7]:						Write only in PL1 or higher
F bit[6]:						Write only in PL1 or higher
T bit[5]:						
M[4:0], bits[4:0]:				Write only in PL1 or higher

-> execution state bits are: 
IT[7:0], J, E, and T bits.

-> setting a mask bit masks the corresponding exception, meaning it cannot be
taken

instructions:
------------
# setend
-> Software can use the SETEND instruction to change the current endianness.

--------------------------------------------------------------------------------
Other Registers:
--------------------------------------------------------------------------------
1) SCTLR: System Control Register (VMSA)
-> The SCTLR provides the top level control of the system, 
including its memory system.
-> Only accessible from PL1 or higher.
-> implementation that includes the Security Extensions, the SCTLR is Banked,
with some bits common to the Secure and Non-secure copies of the register

TE[30]: Thumb/Arm Exception enable including reset 0: Arm 1: Thumb
AFE, bit[29]: Access flag enable in TTB AP[0]
TRE, bit[28] TEX remap enable.
NMFI, bit[27]: Non-maskable FIQ (NMFI) support.
EE, bit[25] Exception Endianness
VE, bit[24]:Interrupt Vectors Enable
U, bit[22]:
FI, bit[21]:Fast interrupts configuration enable
UWXN, bit[20]:
WXN, bit[19]:
HA, bit[17]: Hardware Access flag enable.
RR, bit[14]: Round Robin select: Cache replacement policy
V, bit[13]: Vectors bit
I, bit[12]: Instruction cache enable
Z, bit[11]: Branch prediction enable
SW, bit[10]: SWP and SWPB enable
B, bit[7]: endianness model
CP15BEN, bit[5]: CP15 barrier enable.
C, bit[2]: Cache enable.
A, bit[1]:Alignment check enable
M, bit[0]: MMU enable

Accessing the SCTLR:
--------------------
# Read SCTLR into Rt
MRC p15, 0, <Rt>, c1, c0, 0

# Write Rt to SCTLR
MCR p15, 0, <Rt>, c1, c0, 0


2) SCR, Secure Configuration Register, Security Extensions

# Read SCR into Rt
MRC p15, 0, <Rt>, c1, c1, 0

# Write Rt to SCR
MCR p15, 0, <Rt>, c1, c1, 0
	
