--------------------------------------------------------------------------------
Exceptions
--------------------------------------------------------------------------------
-> When an exception occurs, the core saves the current status and the return
   address, enters a specific mode and possibly disables hardware interrupts.

-> Execution handling for a given exception starts from a fixed memory address
   called an exception vector for that exception.

-> Privileged software can program the location of a set of exception vectors
   into system registers, and they are executed automatically when respective
   exceptions are taken.
--------------------------------------------------------------------------------
Types of Exceptions
--------------------------------------------------------------------------------
1) Interrupts
2) Aborts
3) Reset
4) Exception generating instructions
4a) SVC: supervisor
4b) HVC: Hypervisor
4c) SMC: Secure Monitor Call
5) undefined

--------------------------------------------------------------------------------
Interrupts
--------------------------------------------------------------------------------
-> two types: IRQ, FIQ

-> FIQ is higher priority than IRQ

-> FIQ also has some potential speed advantages owing to its position in the
   vector table and the higher number of banked registers available in FIQ mode.

-> This potentially saves clock cycles on pushing registers to the stack within
   the handler.

-> external hardware asserts an interrupt request line and the corresponding
   exception type is raised when the current instruction finishes executing.

-> FIQ and IRQ are physical signals to the core. On almost all systems, various
   interrupts sources will be connected using an interrupt controller.

-> The interrupt controller arbitrates and prioritizes interrupts, and in turn
   provides a serialized single signal that is then connected to the FIQ or IRQ
   signal of the core.

-> Because the occurrence of IRQ and FIQ interrupts are not directly related to
   the software being executed by the core at any given time, they are
   classified as asynchronous exceptions.

-> FIQ is reserved for a single, high-priority interrupt source that requires a
   guaranteed fast response time, with IRQ used for all of the other interrupts
   in the system.

-> As FIQ is the last entry in the vector table, the FIQ handler can be placed
   directly at the vector location and run sequentially from that address. This
   avoids a branch instruction and any associated delay, speeding up FIQ
   response times.

-> The extra banked registers available in FIQ mode relative to other modes
   allows state to be retained between calls to the FIQ handler, again
   increasing execution speed by potentially removing the need to push some
   registers before using them.

-> A further key difference between IRQ and FIQ is that the FIQ handler is not
   expected to generate any other exceptions. FIQ is therefore reserved for
   special system-specific devices which have all their memory mapped and no
   need to make SVC calls to access kernel functions.

--------------------------------------------------------------------------------
Aborts
--------------------------------------------------------------------------------
1) prefetch abort: Failed instruction fetch
2) data abort: Failed data accesses
3) synchronous abort
4) asynchronous abort

Source of Abort: (External memory & MMU):

1) They can come from the external memory system giving an error response on a
   memory access. indicating perhaps that the specified address does not
   correspond to real memory in the system

2) Alternatively, the abort can be generated by the Memory Management Unit (MMU)
   of the core. An operating system can use MMU aborts to dynamically allocate
   memory to applications.

--------------------------------------------------------------------------------
About Prefetch:
--------------------------------------------------------------------------------

1) An instruction can be marked within the pipeline as aborted, when it is
   fetched. The exception takes place before the instruction executes.

2) The prefetch abort exception is taken only if the core then tries to execute
   it.   
   
3) If the pipeline is flushed before the aborted instruction reaches the execute
   stage of the pipeline, the abort exception will not occur.

--------------------------------------------------------------------------------
About Data abort:
--------------------------------------------------------------------------------

1) A data abort exception happens when a load or store instruction executes and
   is considered to happen after the data read or write has been attempted.

--------------------------------------------------------------------------------
About synchronous abort:
--------------------------------------------------------------------------------

1) An abort is described as synchronous if it is generated as a result of
   execution or attempted execution of the instruction stream.

2) The return address will provide details of the instruction that caused it.

3) Aborts generated by the MMU are always synchronous

--------------------------------------------------------------------------------
About asynchronous abort:
--------------------------------------------------------------------------------

1) An asynchronous abort is not generated by executing instructions.

2) the return address might not always provide details of what caused the abort.

3) The ARMv7 architecture distinguishes between precise and imprecise
   asynchronous aborts.

--------------------------------------------------------------------------------
About Precise asynchronous aborts:
--------------------------------------------------------------------------------

1) For precise asynchronous aborts, the abort handler can be certain which
   instruction caused the abort and that no additional instructions were
   executed after that instruction.

--------------------------------------------------------------------------------
About imprecise asynchronous aborts:
--------------------------------------------------------------------------------

1) This is in contrast to an imprecise asynchronous abort, the result when the
   external memory system reports an error on an unidentifiable access.
   (contrast: means opposite)

2) In this case, the abort handler cannot determine which instruction caused the
   problem, or if additional instructions might have executed after the one that
   generated the abort.	

3) For example, 
	if a buffered write receives an error response from the external memory
	system, additional instructions will have been executed after the store.
	This means that it is impossible for the abort handler to fix the problem
	and return to the application. All it can do is to kill the application that
	caused the problem.

4) Device probing therefore requires special handling, as externally reported
   aborts on reads to non-existent areas will generate imprecise synchronous
   aborts even when such memory is marked as Strongly-ordered, or Device.

5) Detection of asynchronous aborts is controlled by the CPSR A bit. 

6) If the A bit is set, asynchronous aborts from the external memory system will
   be recognized by the core, but no abort exception is generated. Instead, the
   core keeps the abort pending until the A bit is cleared and takes an
   exception at that time. Kernel code will use a barrier instruction to ensure
   that pending asynchronous aborts are recognized against the correct
   application.If a thread has to be killed because of an imprecise abort, it
   must be the correct one!

--------------------------------------------------------------------------------
Reset
--------------------------------------------------------------------------------

1) All cores have a reset input and will take the reset exception immediately
   after they have been reset.

2) It is the highest priority exception and cannot be masked.

3) This exception is used to execute code on the core to initialize it, after
   power up.

--------------------------------------------------------------------------------
Exceptions generating instructions
--------------------------------------------------------------------------------
1) Execution of certain instructions can generate exceptions. Such instructions
   are typically executed to request a service from software that runs at a
   higher privilege level.

2) SVC: supervisor call
   this instruction enables user mode programs to reqeust an operating system
   service

3) HVC: hypervisor call
   Available if the virtualization extenstions are implemented. This enables the
   guest OS to request Hypervisor services.

4) SMC: secure monitor call
   Available if the security instructions are implemented. Enables the normal
   world to request secure world services

--------------------------------------------------------------------------------
Undefined
--------------------------------------------------------------------------------
1) Any attempt to execute an instruction that is not recognized by the core
   generates an UNDEFINED exception.

--------------------------------------------------------------------------------
Exception Vector table
--------------------------------------------------------------------------------
-> In the ARM architecture, exception vectors are stored in a table, called the
   exception vector table.

-> The table base is programmed in a system register by privileged software so
   that the core can locate the respective handler when an exception occurs.

-> Vectors for individual exception can therefore be located at fixed offsets
   from the beginning of the table.

-> Separate vector tables can be configured for Secure PL1, Non-secure PL1,
   Secure monitor and Non-secure PL2 privilege levels.

-> You can write the exception handlers in either ARM or Thumb code. 

-> The CP15 SCTLR.TE bit is used to specify whether exception handlers will use
   ARM or Thumb.

-> When handling exceptions, the prior mode, state, and registers of the core
   must be preserved so that the program can be resumed after the exception has
   been handled.

--------------------------------------------------------------------------------
Exception priorites
--------------------------------------------------------------------------------
-> when execption occur simultaneously, each exception is handled in trun before
   returning to the application

-> some exceptions are mutually exclusive.

-> All exceptions disable IRQ, only FIQ and reset disables FIQ. This is done by
   core automatically setting the CPSR I (IRQ) and F(FIQ) bits.

-> Exception handling on the core is controlled through the use of an area of
   memory called the vector table. This lives by default at the bottom of the
   memory map in word-aligned addresses from 0x00 to 0x1C.
   
-> Most of the cached cores enable the vector table to be moved from 0x0 to
   0xFFFF0000.

-> The situation is more complicated for cores with 
   Security Extensions: 3 vector tables, 
   a) Non-secure, 
   b) Secure and 
   c) Secure Monitor

   Virtualization Extensions: 4 vector tables:
   d) adds Hypervisor vector table to above three

   For cores with MMU: all these vector address are virtual

--------------------------------------------------------------------------------
Vector table: Exception vector table address
--------------------------------------------------------------------------------
-> The default vector base address is 0x0000 0000
-> but most ARM cores permit the vector base address to be moved to 0xFFFF 0000
-> 0xFFFF 0000(HIVECS) is the default address selected by the linux kernel
-> vector table entry almost always contains one of the following two forms of
   branches

   B<label>
   -> This performs a PC-relative branch.
   -> It is suitable for calling exception handler code that is close enough in
      memory that the 24-bit field provided in the branch instruction is large
      enough to encode the offset.

   LDR PC,[PC,#offset]
   -> This loads the PC from a memory location whose address is defined relative
      to the address of the exception instruction.
   -> This lets the exception handler be placed at any arbitrary address within
      the full 32-bit memory space (but takes some extra cycles relative to the
	  simple branch).

--------------------------------------------------------------------------------
Normal		High			Mode(Secure, Non Secure, Hypervisor, Monitor)
--------------------------------------------------------------------------------
0x0			0xFFFF0000		Secure,Hypervisor(RESET)
0x4			0xFFFF0004		all(UNDEF)
0x8			0xFFFF0008		Secure, Non Secure(SVC): Hypervisor,Monitor(SMC)
0xC			0xFFFF000C		all(Prefetch Abort)
0x10		0xFFFF0010		all(Data Abort)
0x14		0xFFFF0014		Hypervisor(Hyp)
0x18		0xFFFF0018		all(IRQ)
0x1C		0xFFFF001C		all(FIQ)

--------------------------------------------------------------------------------
return instruction
--------------------------------------------------------------------------------
The LR is used to store appropriate return address fo the PC after the exception
has been handled. The return address adjustment is different for each type of
exception

--------------------------------------------------------------------------------
Exception	Adjustment	Return instruction	Instruction returned to
--------------------------------------------------------------------------------
SVC			0 			MOVS PC, R14 		Next instruction
Undef 		0 			MOVS PC, R14 		Next instruction
Prefetch Abort -4 		SUBS PC, R14, #4 	Aborting instruction
Data abort	-8 			SUBS PC, R14, #8 	Aborting instruction if precise
FIQ 		-4 			SUBS PC, R14, #4 	Next instruction
IRQ 		-4 			SUBS PC, R14, #4 	Next instruction

--------------------------------------------------------------------------------
Exception Handling
--------------------------------------------------------------------------------
When an exception occurs, the ARM core automatically does the following:
1. Copies the CPSR to the SPSR_<mode>, the banked register specific to the
   (non-user) mode of operation.
2. Stores a return address in the Link Register (LR) of the new mode.
3. Modifies the CPSR mode bits to a mode associated with the exception type.
• The other CPSR mode bits are set to values determined by bits in the CP15
  System Control Register.
• The T bit is set to the value given by the CP15 TE bit.
• The J bit is cleared and the E bit (Endianness) is set to the value of the EE
  (Exception Endianness) bit.
  This enables exceptions to always run in ARM or Thumb state and in little or
  big-endian, irrespective of the state the core was in before the exception.
4. Sets the PC to point to the relevant instruction from the exception vector
  table.
5. It is always necessary for the exception handler software to save
   registers onto the stack immediately on exception entry.
6. A special assembly language instruction is provided to assist with saving the
   necessary registers, called SRS (Store Return State). This instruction pushes
   the LR and SPSR onto the stack of any mode.

--------------------------------------------------------------------------------
Exit from exception handling
--------------------------------------------------------------------------------
1) Restore the CPSR from the saved SPSR
2) set the PC to the return address offset
3) The Return From Exception (RFE) instruction pops the link reigster(LR) and
   SPSR off the current mode stack

--------------------------------------------------------------------------------
Abort Handler
--------------------------------------------------------------------------------
-> Embedded systems:
In many embedded systems, an abort indicates an unexpected error and the handler
will record any diagnostic information, report the error and have the
application (or system) quit gracefully.

-> MMU enabled systems:
the abort handler can load the required virtual page into physical memory. In
effect, it tries to fix the cause of the original abort and then return to the
instruction that aborted and re-execute it.

-> CP15 register: 
the fault address register provide the address of memory that caused an abort
and the reason for the abort.
--> Reason might be:
a) lack of access permission
b) external abort or an address translation fault

--------------------------------------------------------------------------------
undefined instruction handling
--------------------------------------------------------------------------------
-> An undefined instruction exception is taken if the core tries to execute an
instruction with an opcode, described in the ARM arch specification as
undefined.

-> or when a coprocessor instruction is executed but no coprocessor recognizes
it as an instruction that it can execute.

Software emulation: like soft VFP (virtual floating point):
-> is possible that the VFP hardware cannot handle the particular instruction
   and wants to call software to emulate it.	Alternatively, the VFP hardware
   might be disabled, and you take the exception so that it can be enabled
   and then re-execute the instruction.
-> Such emulators are called through the undefined instruction vector. They
   examine the instruction opcode that caused the exception and determine what
   action to take.
Kill application:	
-> If there is no software that makes use of undefined or coprocessor
   instructions, the handler for the exception must record suitable debug
   information and kill the application that failed because of this
   unexpected event.
User breakpoints:
-> An additional use for the undefined instruction exception in some cases is to
   implement user breakpoints.

--------------------------------------------------------------------------------
SVC exception handling
--------------------------------------------------------------------------------
-> A supervisor call (SVC) is typically used to enable User mode code to access
OS functions. For example, if user code wants to access privileged parts of the
system.

What is this? explore more.
-> Parameters can be passed to the SVC handler either in registers or (less
frequently) by using the comment field within the opcode.

-> Both ARM and Thumb instruction sets have the SVC instruction

Linux kernel SVC usage:
_start:
MOV R0, #1			@ STDOUT
ADR R1, msgtext		@ Address
MOV R2, #13			@ Length
MOV R7, #4			@ sys_write
SVC #0
....
.align 2
msgtxt:
.asciz "Hello World\n"
	
--------------------------------------------------------------------------------
Linux exception program flow
--------------------------------------------------------------------------------
-> Linux utilizes cross platform framework for exception handling that does not
distinguish between different privileged core modes when handling exceptions.

-> ARM implementation uses an exception handler stub to enable the kernel to
handle all exceptions in SVC mode.

-> All exceptions other than SVC and IFQ use the stub to switch to SVC mode and
invoke the correct exception handler

--------------------------------------------------------------------------------
Linux Boot process
--------------------------------------------------------------------------------
-> During the boot process, the kernel will allocate a 4KB page as the vector
page.

-> It maps this to the location of the exception vectors, virtual address
0xFFFF0000 or 0x00000000. This is done ny devicemaps_init() in the file 
arch/arm/mm/mmu.c

-> after above, trap_init (arch/arm/kernel/traps.c), copies the exception vector
table, exception stubs and kuser helpers into the vector page.(address: 0x200)

-> kuser helpers copied to 0x1000 - kuser_sz

unsigned long vectors = CONFIG_VECTORS_BASE;
memcpy((void *)vectors, __vectors_start, __vectors_end - __vectors_start);
memcpy((void *)vectors + 0x200, __stubs_start, __stubs_end - __stubs_start);
memcpy((void *)vectors + 0x1000 - kuser_sz, __kuser_helper_start, kuser_sz);

-> When the copying is complete, the kernel exception handler is in its runtime
dynamic status, ready to handle exceptions.

--------------------------------------------------------------------------------
Interrupt dispatch
--------------------------------------------------------------------------------
-> There are two different handlers, __irq_usr and __irq_svc . These save all of
the core registers and use a macro get_irqnr_and_base that indicates if there is
an interrupt pending.

-> The handlers loop around this code until no interrupts remain. If there is an
interrupt, the code will branch to do_IRQ that exists in arch/arm/kernel/irq.c.

-> When the interrupt is completed, you would normally have to check whether or
not the handler has done something that requires the kernel scheduler to be
called. If the scheduler decides to go to a different thread, the one that was
originally interrupted stays dormant until it is selected to run again.


