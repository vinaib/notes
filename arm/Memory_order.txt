--------------------------------------------------------------------------------
Memory Ordering
--------------------------------------------------------------------------------
[ref]: https://en.wikipedia.org/wiki/Memory_ordering
- Memory ordering describes the order of accesses to computer memory by a CPU. 
- Memory ordering generated by the compiler during compile time, or 
- Memory ordering generated by a CPU during runtime

Why Memory reorder?
Memory reordering can be used to fully utilize the bus-bandwidth of different
types of memory such as caches and memory banks

Memory reordering in Single/Uni processor:
- On most modern uniprocessors memory operations are not executed in the order
  specified by the program code.
- In single threaded programs all operations appear to have been executed in the
  order specified, with all out-of-order execution hidden to the programmer.


Memory reordering in Multiprocessor:
- in multi-threaded environments (or when interfacing with other hardware via
  memory buses) this can lead to problems. To avoid problems, memory barriers
can be used in these cases.


Compile-time memory barrier implementation:
- These barriers prevent a compiler from reordering instructions during compile
  time â€“ they do not prevent reordering by CPU during runtime.

- The GNU inline assembler statement:
asm volatile("" ::: "memory");
__asm__ __volatile__ ("" ::: "memory");

The C11/C++11 function:
atomic_signal_fence(memory_order_acq_rel);


