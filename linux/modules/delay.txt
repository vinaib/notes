--------------------------------------------------------------------------------
Timer (Hz: <linux/param.h>)
--------------------------------------------------------------------------------
-> Timer interrupts are generated by the systemâ€™s timing hardware at regular
intervals.

-> this interval is programmed at boot time by the kernel according to the value
of HZ , which is an architecture-dependent value defined in <linux/param.h> or a
subplatform file included by it.

-> Default values in the distributed kernel source range from 50 to 1200 ticks
per second on real hardware.

-> down to 24 for software simulators

-> Most platforms run at 100 or 1000 interrupts per second.
(x86 defaults to 1000)

-> if you change Hz value, kernel and all modules need to be recompiled

-> With current versions, however, the best approach to the timer interrupt is
to keep the default value for HZ , by virtue of our complete trust in the kernel
developers, who have certainly chosen the best value.

--------------------------------------------------------------------------------
Jiffies (<linux/jiffies.h> or include <linux/sched.h>)
--------------------------------------------------------------------------------
-> Jiffies is a internal kerneal counter 64 bit variable even on 32 bit
architecture and is called jiffies_64.

-> Every time a timer interrupt occurs, the value of an internal kernel counter
is incremented.

-> The counter is initialized to 0 at system boot, so it represents the number
of clock ticks since last boot.

Access
------
-> driver writers normally access the jiffies variable, an unsigned long that is
the same as either jiffies_64 or its least significant bits.

-> Using jiffies is usually preferred because it is faster, and accesses to the
64-bit jiffies_64 value are not necessarily atomic on all architectures.

-> Needless to say, both jiffies and jiffies_64 must be considered read-only.

-> Whenever your code needs to remember the current value of jiffies , it can
simply access the unsigned long variable, which is declared as volatile to tell
the compiler not to optimize memory reads.

-> You need to read the current counter whenever your code needs to calculate a
future time stamp, as shown in the following example:

#include <linux/jiffies.h>
unsigned long j, stamp_1, stamp_half, stamp_n;

j = jiffies;			/* read the current value */
stamp_1= j + HZ;		/* 1 second in the future */	
stamp_half = j + HZ/2;	/* half a second */
stamp_n = j + n * HZ / 1000; /* n milliseconds */

on 32-bit platforms the counter wraps around only once every 50 days when HZ is
1000, your code should be prepared to face that event.

diff = (long)t2 - (long)t1;
msec = diff * 1000 / HZ;

/* older structure: represents seconds and microseconds */
struct timeval

/* newer structure: represents second and nanoseconds */
struct timespec

The kernel exports four helper functions to convert time values expressed as
jiffies to and from those structures:

#include <linux/time.h>

unsigned long timespec_to_jiffies(struct timespec *value);
void jiffies_to_timespec(unsigned long jiffies, struct timespec *value);
unsigned long timeval_to_jiffies(struct timeval *value);
void jiffies_to_timeval(unsigned long jiffies, struct timeval *value);

-> On 32 bit systems, accessing 64 bit jiffy count is not straightforward as
accessing jiffies. 

-> while on 64 bit computer, the two variables are acutally one.






