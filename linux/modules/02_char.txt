Device numbers:
--------------------------------------------------------------------------------
<linux/types.h> : dev_t
--------------------------------------------------------------------------------
major: identifies the driver
minor: which device is being referred to. Driver can drive multiple devices.

data struct: dev_t (unsigned int): 32 bit:
				      12 bits for major number
				      20 bits for minor number

Even if 12 bits are allocated for major number, the maximum is 511.
What about 3 more bits?
--------------------------------------------------------------------------------
<linux/kdev_t.h>: Helper macros: 
--------------------------------------------------------------------------------
MAJOR(dev_t dev)
MINOR(dev_t dev)

MKDEV(int major, int minor)

--------------------------------------------------------------------------------
<linux/fs.h>: Allocating char Device numbers: static
--------------------------------------------------------------------------------
# int register_chrdev_region(dev_t first, unsigned int count, char *name);

register_chrdev_region works well if you know ahead of time exactly which device
numbers you want.

first: beginning device number of the range you would like to allocate
	minor: minor number portion of first is most often 0
	major: user has to choose cautiosly 
count: total number of contiguous device numbers you are requesting.
name: name is the name of the device. It will appear in /proc/devices and sysfs
      (/sys/dev/char/).

return: 0 on success
	< 0 on erro
--------------------------------------------------------------------------------
<linux/fs.h>: Allocating char Device numbers: Dynamic
--------------------------------------------------------------------------------
int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, 
		char *name);

kernel will allocate a major number for you on the fly

# dev is an output-only parameter that will, on successful completion, hold the 
  first number in your allocated range.

# firstminor should be the requested first minor number to use

# count and name parameters work like those given to request_chrdev_region

--------------------------------------------------------------------------------
<linux/fs.h>: Deallocating char Device numbers
--------------------------------------------------------------------------------
void unregister_chrdev_region(dev_t first, unsigned int count);

# Regardless of how you allocate your device number, free using
  unregister_chrdev_region.

# usual place to call would be in your module’s cleanup function

--------------------------------------------------------------------------------
Three important Data Structures: file_operations, file, inode <linux/fs.h>
--------------------------------------------------------------------------------
filp/file
# Each open file represented internally by a file structure. The file structure
# represents an open file. It is created by the kernel on open and is passed to
# any function that operates on the file, until the last close(all instances).

The most imp fields of struct file are:
---------------------------------------	
mode_t f_mode; FMODE_READ, FMODE_WRITE

loff_t f_pos;

struct file_operations *f_op;

struct dentry *f_dentry;
The directory entry (dentry) structure associated with the file. Device driver writ-
ers normally need not concern themselves with dentry structures, other than to
access the inode structure as filp->f_dentry->d_inode .

unsigned int f_flags: O_RDONLY , O_NONBLOCK, O_SYNC

filp->private_data: The open system call sets this pointer to NULL before
calling the open method for the driver. You are free to make its own use of the
field or to ignore it; private_data is a useful resource for preserving state
information across system calls.

drivers never create file structures; they only access structures created
elsewhere.

file_operations/f_ops
# and it is associated with its own set of functions (f_ops). The operations are
mostly in charge of implementing the system calls. The operations associated
with file. The kernel assigns the pointer as part of its implementation of
open. The value in filp->f_op is never saved by the kernel for later reference;
this means that you can change the file operations associated with your file, and
the new methods will be effective after you return to the caller. This practice
allows the implementation of several behaviors under the same major number
without introducing overhead at each system call.

# We can consider the file to be an “object” and the (f_ops) functions operating
  on it to be its “methods".

inode
The inode structure is used by the kernel internally to represent files. 
Therefore, it is different from the file structure that represents an open file
descriptor.There can be numerous file structures representing multiple open
descriptors on a single file, but they all point to a single inode structure.

As a general rule, only two fields of this structure are of interest for writing
driver code.

dev_t i_rdev;
For inodes that represent device files, this field contains the actual device number.

macros that can be used to obtain the major and minor number from an inode:
----------------------------------------------------------------------------
unsigned int iminor(struct inode *inode);
unsigned int imajor(struct inode *inode);

struct cdev *i_cdev;
struct cdev is the kernel’s internal structure that represents char devices; this
field contains a pointer to that structure when the inode refers to a char device
file.

--------------------------------------------------------------------------------
Char Device Registration : <linux/cdev.h>
--------------------------------------------------------------------------------
Before the kernel invokes your device’s operations, you must allocate and
register one or more of these structures.

There are two ways of allocating and initializing one of these structures. 

# If you wish to obtain a standalone cdev structure at runtime:

struct cdev *my_cdev = cdev_alloc();
my_cdev->ops = &my_fops;

# Chances are, however, that you will want to embed the cdev structure within a
device-specific structure of your own; that is what scull does. In that case,
you should initialize the structure that you have already allocated with:

void cdev_init(struct cdev *cdev, struct file_operations *fops);

# struct cdev has an owner field that should be set to THIS_MODULE.

Inform kernel about cdev:
-------------------------
int cdev_add(struct cdev *dev, dev_t num, unsigned int count);

as soon as cdev_add returns, your device is “live” and its operations can be
called by the kernel. You should not call cdev_add until your driver is
completely ready to handle operations on the device.

To remove a char device from the system, call:
----------------------------------------------
void cdev_del(struct cdev *dev);

Older way of char device registration:
---------------------------------------
int register_chrdev(unsigned int major, const char *name,
struct file_operations *fops);

int unregister_chrdev(unsigned int major, const char *name);

--------------------------------------------------------------------------------
The Open Method: int (*open)(struct inode *inode, struct file *filp);
--------------------------------------------------------------------------------
# used to do initialization

# Check for device-specific errors (such as device-not-ready or similar hardware
problems)

# Initialize the device if it is being opened for the first time

# Update the f_op pointer, if necessary

# Allocate and fill any data structure to be put in filp->private_data

# The first order of business, however, is usually to identify which device is being
opened. is it my device requested? Inode have the i_cdev which contains the cdev
struct we setup/added before through cdev_add(); The only problem is that we do
not normally want the cdev structure itself, we want the scull_dev structure
that contains the cdev structure.

struct scull_dev *sdevp;
	sdevp = container_of(inode->i_cdev, struct scull_dev, cdev);
filp->private_data = dev

--------------------------------------------------------------------------------
The Release Method: int (*release)(struct inode *inode, struct file *filp);
--------------------------------------------------------------------------------
The device method should perform the following tasks:

• Deallocate anything that open allocated in filp->private_data
• Shut down the device on last close

Relationship between close and relase:
--------------------------------------
the dup and fork system calls create copies of open files without
calling open. each of those copies is then closed at program termination, and 
not every close system call causes the release method to be invoked.

The kernel keeps a counter of how many times a file structure is being used.
Neither fork nor dup creates a new file structure (only open does that); they
just increment the counter in the existing structure. The close system call
executes the release method only when the counter for the file structure drops
to 0 , which happens when the structure is destroyed. This relationship between
the release method and the close system call guarantees that your driver sees
only one release call for each open.

the previous discussion applies even when the application terminates without
explicitly closing its open files: the kernel automatically closes any file at
process exit time by internally using the close system call.

relation between close and flush:
----------------------------------
Note that the flush method is called every time an application calls close.

--------------------------------------------------------------------------------
read/write Method:
ssize_t read(struct file *filp, char __user *buff, size_t count, loff_t *offp);

ssize_t write(struct file *filp, const char __user *buff, size_t count, 
		loff_t *offp);
--------------------------------------------------------------------------------
__user *buff argument to the read and write methods is a user space pointer.
Therefore it cannot be directly dereferenced by kernel code. 

Reasons why userspace pointer cannot be directly dereferenced by kernel code:
-> Depending on which architecture your driver is running on, and how the kernel
was configured, the user-space pointer may not be valid while running in kernel
mode at all. There may be no mapping for that address, or it could point to some
other, random data

-> Even if the pointer does mean the same thing in kernel space, user-space mem-
ory is paged, and the memory in question might not be resident in RAM when
the system call is made. Attempting to reference the user-space memory directly
could generate a page fault, which is something that kernel code is not allowed
to do. The result would be an “oops,” which would result in the death of the
process that made the system call.

-> The pointer in question has been supplied by a user program, which could be
buggy or malicious. If your driver ever blindly dereferences a user-supplied
pointer, it provides an open doorway allowing a user-space program to access or
overwrite memory anywhere in the system. If you do not wish to be responsible
for compromising the security of your users’ systems, you cannot ever derefer-
ence a user-space pointer directly.

<asm/uaccess.h>:
----------------------------
TO access the user-space buffer in order to get its job done. This access must
always be performed by special, kernel-supplied functions in order to be safe.

unsigned long copy_to_user(void __user *to,
	const void *from,
	unsigned long count);

unsigned long copy_from_user(void *to,
	const void __user *from,
	unsigned long count);

-> checks for whether the user space pointer is valid.
-> If the pointer is invalid, no copy is performed; 
-> if an invalid address is encountered during the copy, on the other hand, only
part of the data is copied.
-> In both cases, the return value is the amount of memory still to be copied.

Aside: (__copy_to_user,__copy_from_user vs copy_to_user, copy_from_user)
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
However, it’s worth noting that if you don’t need to check the user-space
pointer you can invoke __copy_to_user and __copy_from_user instead. This is
useful, for example, if you know you already checked the argument.

*Important*
+++++++++++
The net result for the driver writer is that any function that accesses user
space must be reentrant, must be able to execute concurrently with other driver
functions, and, in particular, must be in a position where it can legally
sleep.

read and write return value:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
A return value greater than or equal to 0, instead, tells the calling program
how many bytes have been successfully transferred. If some data is transferred
correctly and then an error happens, the return value must be the count of bytes
successfully transferred, and the error does not get reported until the next
time the function is called. Implementing this convention requires, of course,
that your driver remember that the error has occurred so that it can return
the error status in the future.

The read method: RULES
--------------------------------------------------------------------------------
-> return value equal to count argument, the requested number of bytes
transferred. this is optimal case

-> return is positive and smaller than count. Only part of data has been
transferred. In these cases most applications retries the read.

-> return value is 0, end of file is reached.

-> return value is negative, which means error. typical values are EINTR/EFAULT.

-> read system could block if there is no data

-> if current read position is greater than the device size, the read method
returns 0 to signal that there is no data available. 
for example, this can happen if process A is reading the device while process B
opens it for writing, thus truncating the device to a length of 0. Process A
suddenly finds itself past end-of-file and the next read call returns 0.

The write method: RULES
--------------------------------------------------------------------------------
-> return value equal to count, the requested number of bytes has been
transferred

-> return is positive and smaller than count. only part of the data has been
transferred. The program will most likely retry writing the rest of the data.

-> return value is 0, nothing was written. This result is not an error, and
there is no reason to return an error code. Once again, the standard library
retries the call to write.

-> A negative value means an error occurred, as defined in <linux/errno.h>

-> blocking read, non blocking read

readv and writev
--------------------------------------------------------------------------------
These “vector” versions of read and write take an array of structures, each of
which contains a pointer to a buffer and a length value.

A readv call would then be expected to read the indicated amount into each
buffer in turn. writev, instead, would gather together the contents of each
buffer and put them out as a single write operation.

If your driver does not supply methods to handle the vector operations, readv
and writev are implemented with multiple calls to your read and write methods.
In many situations, however, greater efficiency is acheived by implementing
readv and writev directly.

The prototypes for the vector operations are:

ssize_t (*readv) (struct file *filp, const struct iovec *iov,
	unsigned long count, loff_t *ppos);

ssize_t (*writev) (struct file *filp, const struct iovec *iov,
	unsigned long count, loff_t *ppos);

-> The iovec structure, defined in <linux/uio.h>
struct iovec {
	void _ _user *iov_base;
	__kernel_size_t iov_len;
};
-> Each iovec describes one chunk of data to be transferred; it starts at
iov_base (in user space) and is iov_len bytes long.

-> The count parameter tells the method how many iovec structures there are.
These structures are created by the application, but the kernel copies them into
kernel space before calling the driver.

-> The simplest implementation of the vectored operations would be a
straightforward loop that just passes the address and length out of each iovec
to the driver’s read or write function. Often, however, efficient and correct
behavior requires that the driver do something smarter.

--------------------------------------------------------------------------------
ioctl: 
--------------------------------------------------------------------------------
-> IOCTL is a common interface for device control

-> In user space, the ioctl system call has the following prototype:
	int ioctl(int fd, unsigned long cmd, ...);
	
	The third argument does not represents variable arguments, but a single
	optional argument, traditionally identified as char *argp.

	The actual nature of the third argument depends on the specific control
	command being issued (the second argument). Some commands take no arguments,
	some take an integer value, and some take a pointer to other data.

-> The ioctl driver method prototype 
	int (*ioctl) (struct inode *inode, struct file *filp, unsigned int cmd,
			unsigned long arg);

-> The inode and filp pointers are the values corresponding to the file
descriptor fd passed on by the application and are the same parameters passed to
the open method.

-> The cmd argument is passed from the user unchanged, 

-> and the optional arg argument is passed in the form of an unsigned long ,
regardless of whether it was given by the user as an integer or a pointer.
If the invoking program doesn’t pass a third argument, the arg value
received by the driver operation is undefined. Because type checking is
disabled on the extra argument.

--------------------------------------------------------------------------------
Choosing the ioctl commands: 
--------------------------------------------------------------------------------
The ioctl command numbers should be unique across the system in order to prevent
errors caused by issuing the right command to the wrong device.
like eg: change baud rate of an audio device

If each ioctl number is unique, the application gets an EINVAL error rather than
succeeding in doing something unintended.

include/uapi/asm-generic/ioctl.h
Documentation/ioctl/ioctl-number.txt

--------------------------------------------------------------------------------
Return value
--------------------------------------------------------------------------------
If user issues invalid command then 
-EINVAL (invalid argument)
But as per posix standard -ENOTTY should be returned. This error code is
interpreted by the C library as "inappropriate ioctl for device".

--------------------------------------------------------------------------------
The predefined commands
--------------------------------------------------------------------------------
Although the ioctl system call is most often used to act on devices, a few
commands are recognized by the kernel. Note that these commands, when applied to
your device, are decoded before your own file operations are called. Thus, if
you choose the same number for one of your ioctl commands, you won’t ever see
any request for that command, and the application gets something unexpected
because of the conflict between the ioctl numbers.

The predefined commands are divided into three groups:
• Those that can be issued on any file (regular, device, FIFO, or socket)
• Those that are issued only on regular files
• Those specific to the filesystem type

The following ioctl commands are predefined for any file, including device-special
files:
FIOCLEX
FIONCLEX
FIOASYNC
FIOQSIZE
FIONBIO

--------------------------------------------------------------------------------
Using the ioctl Argument
--------------------------------------------------------------------------------
-> If argument is an integer, it can be used directly

-> If it is a pointer, some care must be taken
When a pointer is used to refer to user space, we must ensure that the user
address is valid. An attempt to access an unverified user-supplied pointer can
lead to incorrect behavior, a kernel oops, system corruption, or security
problems. It is the driver’s responsibility to make proper checks on every
user-space address it uses and to return an error if it is invalid.

--------------------------------------------------------------------------------
Address verification: access_ok
--------------------------------------------------------------------------------
-> copy_from_user and copy_to_user functions, which can be used to safely move
data to and from user space. Those functions can be used in ioctl methods as
well, but ioctl calls often involbe small data items that can be more
efficiently manipulated through other means.

-> To start, address verification (without transferring data) is implemented by
the function access_ok, which is declared in <asm/uaccess.h>: 

int access_ok(int type, const void *addr, unsigned long size);

-> The first argument should be either VERIFY_READ or VERIFY_WRITE , depending
on whether the action to be performed is reading the user-space memory area or
writing it.

-> The addr argument holds a user-space address

-> size is a byte count

-> If ioctl,for instance, needs to read an integer value from user space, size
is sizeof(int). 

-> If you need to both read and write at the given address, use VERIFY_WRITE ,
since it is a superset of VERIFY_READ.

-> Unlike most kernel functions, access_ok returns a boolean value: 1 for
success (access is OK) and 0 for failure (access is not OK). If it returns
false, the driver should usually return -EFAULT to the caller.

-> There are a couple of interesting things to note about access_ok. 
# First, it does not do the complete job of verifying memory access; it only
checks to see that the memory reference is in a region of memory that the
process might reasonably have access to. In particular, access_ok ensures that
the address does not point to kernel-space memory.

# Second, most driver code need not actually call access_ok. The memory-access
routines described later take care of that for you.

The scull source exploits the bitfields in the ioctl number to check the
arguments before the switch:

int err = 0, tmp;
int retval = 0;

/*
* extract the type and number bitfields, and don't decode
* wrong cmds: return ENOTTY (inappropriate ioctl) before access_ok( )
*/
if (_IOC_TYPE(cmd) != SCULL_IOC_MAGIC) 
	return -ENOTTY;

if (_IOC_NR(cmd) > SCULL_IOC_MAXNR) 
	return -ENOTTY;

/*
* the direction is a bitmask, and VERIFY_WRITE catches R/W
* transfers. `Type' is user-oriented, while
* access_ok is kernel-oriented, so the concept of "read" and
* "write" is reversed
*/
if (_IOC_DIR(cmd) & _IOC_READ)
	err = !access_ok(VERIFY_WRITE, (void __user *)arg, _IOC_SIZE(cmd));
else if (_IOC_DIR(cmd) & _IOC_WRITE)
	err = !access_ok(VERIFY_READ, (void __user *)arg, _IOC_SIZE(cmd));
if (err) 
	return -EFAULT;

After calling access_ok, the driver can safely perform the actual transfer. In
addition to the copy_from_user and copy_to_user functions, the programmer can
exploit a set of functions that are optimized for the most used data sizes (one,
two, four, and eight bytes). These functions are described in the following list
and are defined in <asm/uaccess.h>:

--------------------------------------------------------------------------------
put_user(datum, ptr)		// Performs access_ok
__put_user(datum, ptr)		// skips access_ok
--------------------------------------------------------------------------------
These macros write the datum to user space; they are relatively fast and should
be called instead of copy_to_user whenever single values are being transferred.
The macros have been written to allow the passing of any type of pointer to
put_user,as long as it is a user-space address. 

The size of the data transfer depends on the type of the ptr argument and is
determined at compile time using the sizeof and typeof compiler builtins.

As a result, if ptr is a char pointer, one byte is transferred, and so on for
two, four, and possibly eight bytes.

put_user checks to ensure that the process is able to write to the given
memory address. It returns 0 on success, and -EFAULT on error.

__put_user performs less checking (it does not call access_ok), but can still
fail if the memory pointed to is not writable by the user. Thus, __put_user
should only be used if the memory region has already been verified with
access_ok.

--------------------------------------------------------------------------------
get_user(local, ptr)		// Performs access_ok
__get_user(local, ptr)		// skips access_ok
--------------------------------------------------------------------------------
These macros are used to retrieve a single datum from user space. Again,
 __get_user should only be used if the address has already been verified
 with access_ok.

If an attempt is made to use one of the listed functions to transfer a value
that does not fit one of the specific sizes, the result is usually a strange
message from the compiler, such as “conversion to non-scalar type requested.” In
such cases, copy_to_user or copy_from_user must be used.

--------------------------------------------------------------------------------
Capabilities and Restricted Operations: <linux/capability.h>
--------------------------------------------------------------------------------
Access to a device is controlled by the permissions on the device file(s), and
the driver is not normally involved in permissions checking.

If user is granted read/write permission on the device, but some control
operations should still be denied.

For example, not all users of a tape drive should be able to set its default
block size, and a user who has been granted read/write access to a disk device
should probably still be denied the ability to format it.

In cases like these, the driver must perform additional checks to be sure that
the user is capable of performing the requested operation.

Unix vs Linux Capabilities:
Unix:
Unix systems have traditionally restricted privileged operations to the
superuser account. This meant that privilege was an all-or-nothing thing—the
superuser can do absolutely anything, but all other users are highly restricted.

Linux:
The Linux kernel provides a more flexible system called capabilities. A
capability-based system leaves the all-or-nothing mode behind and breaks down
privileged operations into separate subgroups. In this way, a particular user
(or program) can be empowered to perform a specific privileged operation without
giving away the ability to perform other, unrelated operations.

The kernel uses capabilities exclusively for permissions management and exports
two system calls capget and capset, to allow them to be managed from user space.

The full set of capabilities can be found in <linux/capability.h>. These are the
only capabilities known to the system; it is not possible for driver authors or
system administrators to define new ones without modifying the kernel source.

CAP_DAC_OVERRIDE: Data access control
CAP_NET_ADMIN:
CAP_SYS_MODULE: The ability to load or remove kernel modules.
CAP_SYS_RAWIO:
CAP_SYS_ADMIN:
CAP_SYS_TTY_CONFIG:

Before performing a privileged operation, a device driver should check that the
calling process has the appropriate capability; failure to do so could result
user processes performing unauthorized operations with bad results on system
stability or security. Capability checks are performed with the capable function
(defined in <linux/sched.h>):

int capable(int capability);

if (! capable (CAP_SYS_ADMIN))
	return -EPERM;

--------------------------------------------------------------------------------
ioctl: unlocked_ioctl/compat_ioctl
--------------------------------------------------------------------------------
source: https://lwn.net/Articles/119652/

The ioctl() system call has long been out of favor among the kernel developers,
who see it as a completely uncontrolled entry point into the kernel. Given
the vast number of applications which expect ioctl() to be present, however,
it will not go away anytime soon. So it is worth the trouble to ensure that
ioctl() calls are performed quickly and correctly - and that they do not
unnecessarily impact the rest of the system.

ioctl() is one of the remaining parts of the kernel which runs under the Big
Kernel Lock (BKL). In the past, the usage of the BKL has made it possible for
long-running ioctl() methods to create long latencies for unrelated processes.
Recent changes, which have made BKL-covered code preemptible, have mitigated
that problem somewhat. Even so, the desire to eventually get rid of the BKL
altogether suggests that ioctl() should move out from under its protection.

Simply removing the lock_kernel() call before calling ioctl() methods is not an
option, however. Each one of those methods must first be audited to see what
other locking may be necessary for it to run safely outside of the BKL. That is
a huge job, one which would be hard to do in a single "flag day" operation. So a
migration path must be provided. As of 2.6.11, that path will exist.

The patch (by Michael s. Tsirkin) adds a new member to the file_operations
structure:

    long (*unlocked_ioctl) (struct file *filp, unsigned int cmd,
                            unsigned long arg);

If a driver or filesystem provides an unlocked_ioctl() method, it will be called
in preference to the older ioctl(). The differences are that the inode argument
is not provided (it's available as filp->f_dentry->d_inode) and the BKL is not
taken prior to the call. All new code should be written with its own locking,
and should use unlocked_ioctl(). Old code should be converted as time
allows. For code which must run on multiple kernels, there is a new
HAVE_UNLOCKED_IOCTL macro which can be tested to see if the newer method
is available or not.

Michael's patch adds one other operation:

    long (*compat_ioctl) (struct file *filp, unsigned int cmd,
                          unsigned long arg);

If this method exists, it will be called (without the BKL) whenever a 32-bit
process calls ioctl() on a 64-bit system. It should then do whatever is required
to convert the argument to native data types and carry out the request. If
compat_ioctl() is not provided, the older conversion mechanism will be used, as
before. The HAVE_COMPAT_IOCTL macro can be tested to see if this mechanism is
available on any given kernel.

The compat_ioctl() method will probably filter down into a few subsystems. Andi
Kleen has posted patches adding new compat_ioctl() methods to the
block_device_operations and scsi_host_template structures, for example, though
those patches have not been merged as of this writing.

There are a few noteworthy points about compat_ioctl:

-> If you are writing a new device driver that needs ioctl methods (which some
might argue you should not do in the first place), make sure the
data structure are compatible between 32 and 64 bit, so unlocked_ioctl and
compat_ioctl can point to the same function. In particular, data structures
containing must not contain fields that have different sizes (e.g. 'void *' or
'long') or need padding (e.g. 'long long' after 'int') on 64 bit systems.

-> As of 2.6.14, nobody has started converting the network layer to
compat_ioctl, so the next person that needs new compatibility code for socket
ioctls should add the infrastructure for that instead of adding on to
fs/compat_ioctl.c.

-> While the fs/compat_ioctl.c infrastructure still exists, it is valid for
compat_ioctl methods to return -ENOIOCTLCMD for anything they don't know. This
is particularly useful for block or tty devices that have a lot of ioctl numbers
common to all drivers. The vfs layer first calls ->compat_ioctl and if that does
not exist or returns -ENOIOCTLCMD, it scans the list of known conversions
between 32 and 64 bit ioctls and if it finds a valid conversion, it enters the
native 64 bit ->unlocked_ioctl/->ioctl path.

--------------------------------------------------------------------------------
Blocking I/O
--------------------------------------------------------------------------------
# Rules to be followed before keeping a process to sleep.

-> never sleep when you are running in an atomic context.

is that your driver cannot sleep while holding a spinlock, seqlock, or RCU lock.
You also cannot sleep if you have disabled interrupts. It is legal to sleep
while holding a semaphore, but you should look very carefully at any code that
does so. If code sleeps while holding a semaphore, any other thread waiting for
that semaphore also sleeps. So any sleeps that happen while holding semaphores
should be short.

-> after wakeup check for condition you were waiting for

when you wake up, you never know how long your process may have been out of the
CPU or what may have changed in the mean time. You also do not usually know if
another process may have been sleeping for the same event; that process may wake
before you and grab whatever resource you were waiting for. The end result is
that you can make no assumptions about the state of the system after you wake
up, and you must check to ensure that the condition you were waiting for is,
indeed, true.

-> your process cannot sleep unless it is assured that somebody else will wake
it up.
Making it possible for your sleeping process to be found is accomplished through
a data structure called a wait queue. A wait queue is just what it sounds like:
a list of processes, all waiting for a specific event.

--------------------------------------------------------------------------------
wait_queue_head_t 
--------------------------------------------------------------------------------
In Linux, a wait queue is managed by means of a “wait queue head,” a structure
of type wait_queue_head_t , which is defined in <linux/wait.h>. A wait queue
head can be defined and initialized statically with:

## DECLARE_WAIT_QUEUE_HEAD(name);

or dynamicly as follows:

## wait_queue_head_t my_queue;
## init_waitqueue_head(&my_queue);

--------------------------------------------------------------------------------
wait_event
--------------------------------------------------------------------------------
The simplest way of sleeping on condition in the Linux kernel is a macro called
wait_event. The forms of wait_event are:

## process is put into an uninterruptible sleep
wait_event(queue, condition)

## process is interrupted by signals. This returns an integer value that you
should check; a nonzero value means your sleep was interrupted by some sort
of signal and driver probably return -ERESTARTSYS
wait_event_interruptible(queue, condition)

## wait for a limited time, expressed in jiffies, after that time period
expires, the macros return with a value of 0 regardless of how condition
evaluates.
wait_event_timeout(queue, condition, timeout)

## wait_event_interruptible_timeout(queue, condition, timeout)

### queue is wait_queue_head and it is passed by value
### condition is an arbitrary boolean expression, i.e evaluated before and after
sleeping, until condition evaluates to a true value, the process continues to
sleep.

--------------------------------------------------------------------------------
wake_up
--------------------------------------------------------------------------------
Some other thread of execution, a different process, or an interrupt handler,
has to perform the wakeup for you.

void wake_up(wait_queue_head_t *queue);
void wake_up_interruptible(wait_queue_head_t *queue);

-> wake_up wakes up all processes waiting on the given queue.
-> wake_up and wake_up_interruptible are indistinguishable. 
-> convention is wake_up for wait_event
   wake_up_interruptible for wait_event_interruptible

-> wakeup function sets the process into a runnable state
-> performs a context switch to that process if it has a higher priority
-> Other forms of wake up: but most of times wake_up is itself sufficient

# wake_up(wait_queue_head_t *queue);
# wake_up_interruptible(wait_queue_head_t *queue);
wake_up awakens every process on the queue that is not in an exclusive wait, and
exactly one exclusive waiter, if it exists. 
wake_up_interruptible does the same, with the exception that it skips over
processes in an uninterruptible sleep.

# wake_up_nr(wait_queue_head_t *queue, int nr);
# wake_up_interruptible_nr(wait_queue_head_t *queue, int nr);
These functions perform similarly to wake_up, except they can awaken up to nr
exclusive waiters, instead of just one. Note that passing 0 is interpreted as
asking for all of the exclusive waiters to be awakened, rather than none of
them.

# wake_up_all(wait_queue_head_t *queue);
# wake_up_interruptible_all(wait_queue_head_t *queue);
This form of wake_up awakens all processes whether they are performing an
exclusive wait or not though the interruptible form still skips processes doing
uninterruptible waits.

# wake_up_interruptible_sync(wait_queue_head_t *queue);
Normally, a process that is awakened may preempt the current process and be
scheduled into the processor before wake_up returns. In other words, a call to
wake_up may not be atomic. If the process calling wake_up is running in an
atomic context (it holds a spinlock, for example, or is an interrupt handler),
this rescheduling does not happen.

--------------------------------------------------------------------------------
example:
--------------------------------------------------------------------------------
static DECLARE_WAIT_QUEUE_HEAD(wq);
static int flag = 0;

ssize_t sleepy_read (struct file *filp, char __user *buf, size_t count, loff_t *pos)
{
	printk(KERN_DEBUG "process %i (%s) going to sleep\n",
			current->pid, current->comm);
	wait_event_interruptible(wq, flag != 0);
	flag = 0;
	printk(KERN_DEBUG "awoken %i (%s)\n", current->pid, current->comm);
	return 0; /* EOF */
}

ssize_t sleepy_write (struct file *filp, const char __user *buf, size_t count,
	loff_t *pos)
{
	printk(KERN_DEBUG "process %i (%s) awakening the readers...\n",
	current->pid, current->comm);
	flag = 1;
	wake_up_interruptible(&wq);
	return count; /* succeed, to avoid retrial */
}

Interesting point from above example:
--------------------------------------------------------------------------------
Note the use of the flag variable in this example. Since
wait_event_interruptible checks for a condition that must become true, we use
flag to create that condition.

It is interesting to consider what happens if two processes are waiting when
sleepy_write is called. Since sleepy_read resets flag to 0 once it wakes up, you
might think that the second process to wake up would immediately go back to
sleep. On a single-processor system, that is almost always what happens. But it
is important to understand why you cannot count on that behavior. The
wake_up_interruptible call will cause both sleeping processes to wake up. It is
entirely possible that they will both note that flag is nonzero before either
has the opportunity to reset it. For this trivial module, this race condition is
unimportant. In a real driver, this kind of race can create rare crashes that
are difficult to diagnose. If correct operation required that exactly one
process see the nonzero value, it would have to be tested in an atomic manner.

--------------------------------------------------------------------------------
Blocking and Nonblocking Operations
--------------------------------------------------------------------------------
-> when to put a process to sleep: when there is no I/O data/buffers are
available.

-> There are also times when the calling process informs you that it does not
want to block, whether or not its I/O can make any progress at all.

Explicitly nonblocking I/O is indicated by the O_NONBLOCK flag in filp->f_flags
. The flag is defined in <linux/fcntl.h>, which is automatically included by
<linux/fs.h>.

Default behavior: Block
-----------------------
The flag is cleared by default, because the normal behavior of a process waiting
for data is just to sleep.

Blocking behavior
----------------
-> Read
If a process calls read but no data is (yet) available, the process must block.
The process is awakened as soon as some data arrives, and that data is returned
to the caller, even if there is less than the amount requested in the count
argument to the method.

-> Write
If a process calls write and there is no space in the buffer, the process must
block, and it must be on a different wait queue from the one used for reading.
When some data has been written to the hardware device, and space becomes free
in the output buffer, the process is awakened and the write call succeeds,
although the data may be only partially written if there isn’t room in the
buffer for the count bytes that were requested.

O_NONBLOCK
----------
-> The behavior of read and write is different if O_NONBLOCK is specified
-> Read: returns -EAGAIN if a process calls read when no data is available
-> write: returns -EAGAIN, when there is no space in the buffer
-> Open: Usually used when initialization of a device takes time and you may
choose to support O_NONBLOCK in open method to return immedialtely.

Only Read, write and open are affected by O_NONBLOCK flag.

-ERESTARTSYS
------------
the driver returns -ERESTARTSYS to the caller; this value is used internally by
the virtual filesystem (VFS) layer, which either restarts the system call or
returns -EINTR to user space.

--------------------------------------------------------------------------------
Manual sleeps: <linux/sched.h>: scull_p_write
--------------------------------------------------------------------------------
-> manipulating process state:

void set_current_state(int new_state);
TASK_RUNNING: means process is able to run. It is not necessarily executing in
			  the processor at any specific moment.

TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE: correspond to the two types of sleep

-> Yielding the processor
if(!condition)
	schedule()

-> The first step is the creation and initialization of a wait queue entry. That
is usually done with this macro:

DEFINE_WAIT(my_wait);

-> in which name is the name of the wait queue entry variable. You can also do
things in two steps:

wait_queue_t my_wait;
init_wait(&my_wait);

-> The next step is to add your wait queue entry to the queue, and set the
process state. Both of those tasks are handled by this function:

void prepare_to_wait(wait_queue_head_t *queue,
						wait_queue_t *wait,
						int state);
Here, queue and wait are the wait queue head and the process entry,
respectively. state is the new state for the process; it should be either
TASK_INTERRUPTIBLE (for interruptible sleeps, which is usually what you want) or
TASK_UNINTERRUPTIBLE (for uninterruptible sleeps).

-> After calling prepare_to_wait, the process can call schedule—after it has
checked to be sure it still needs to wait. Once schedule returns, it is cleanup
time. That task, too,is handled by a special function:

void finish_wait(wait_queue_head_t *queue, wait_queue_t *wait);

Thereafter, your code can test its state and see if it needs to wait again.

-> signal_pending tells us whether we were awakened by a signal; if so we need
to return to the user and let them try again later

--------------------------------------------------------------------------------
Exclusive waits
--------------------------------------------------------------------------------
-> when a process calls wake_up on a wait queue, all processes waiting on that
queue are made runnable. In many cases, that is the correct behavior.

-> We know that only one of the processes being awakened will succeed in
obtaining the desired resource, and the rest will simply have to sleep again.

-> If the number of processes in the wait queue is large, this “thundering herd”
behavior can seriously degrade the performance of the system.

-> to address "thundering herd" problem, kernel developers added an exclusive
wait option to kernel.

Behavior of exclusive wait: "WQ_FLAG_EXCLUSIVE"
-----------------------------------------------
-> When a wait queue entry has the WQ_FLAG_EXCLUSIVE flag set, it is added to
the end of the wait queue. Entries without that flag are, instead, added to the
beginning.

-> When wake_up is called on a wait queue, it stops after waking the first
process that has the WQ_FLAG_EXCLUSIVE flag set.

-> The end result is that processes performing exclusive waits are awakened one
at a time, in an orderly manner, and do not create thundering herds. The kernel
still wakes up all nonexclusive waiters every time.

-> Putting a process into an interruptible wait is a simple matter of calling
prepare_to_wait_exclusive.

-> void prepare_to_wait_exclusive(wait_queue_head_t *queue,
									wait_queue_t *wait,
									int state);

-> This call, when used in place of prepare_to_wait, sets the “exclusive” flag
in the wait queue entry and adds the process to the end of the wait queue. Note
that there is no way to perform exclusive waits with wait_event and its
variants.

--------------------------------------------------------------------------------
Poll and select
--------------------------------------------------------------------------------
-> Applications that use nonblocking I/O often use the poll, select, and epoll
system calls as well. 

-> poll, select, and epoll have essentially the same functionality

-> each allow a process to determine whether it can read from or write to one or
more open files without blocking.

-> These calls can also block a process until any of a given set of file
descriptors becomes available for reading or writing.

-> they are often used in applications that must use multiple input or output
streams without getting stuck on any one of them.

-> The same functionality is offered by multiple functions

-> select was introduced in BSD unix
-> poll was System V solution
-> epoll is added linux 2.5.45 as a way of making the polling function scale to
thousands of file decriptors

-> This support for all three calls is provided through the driver’s poll method.

# unsigned int (*poll) (struct file *filp, poll_table *wait);

-> The device method is in charge of these two steps:
1. Call poll_wait on one or more wait queues that could indicate a change in the
poll status. If no file descriptors are currently available for I/O, the kernel
causes the process to wait on the wait queues for all file descriptors passed to
the system call.

2. Return a bit mask describing the operations (if any) that could be
immediately performed without blocking.

-> poll_wait(filp, &dev->inq, wait)
	poll_wait adds the waitqueues to the poll_table.

-> the poll method should return POLLHUP if no more data is (or will become)
	available.

Reading data from the device
-----------------------------
• If there is data in the input buffer, the read call should return immediately, with
no noticeable delay, even if less data is available than the application requested,
and the driver is sure the remaining data will arrive soon. You can always return
less data than you’re asked for if this is convenient for any reason (we did it in
scull), provided you return at least one byte. In this case, poll should return
POLLIN|POLLRDNORM.

• If there is no data in the input buffer, by default read must block until at least
one byte is there. If O_NONBLOCK is set, on the other hand, read returns immedi-
ately with a return value of -EAGAIN (although some old versions of System V
return 0 in this case). In these cases, poll must report that the device is unread-
able until at least one byte arrives. As soon as there is some data in the buffer, we
fall back to the previous case.

• If we are at end-of-file, read should return immediately with a return value of 0 ,
independent of O_NONBLOCK . poll should report POLLHUP in this case.

Writing to the device
----------------------
• If there is space in the output buffer, write should return without delay. It can
accept less data than the call requested, but it must accept at least one byte. In
this case, poll reports that the device is writable by returning POLLOUT|POLLWRNORM .

• If the output buffer is full, by default write blocks until some space is freed. If
O_NONBLOCK is set, write returns immediately with a return value of -EAGAIN (older
System V Unices returned 0 ). In these cases, poll should report that the file is not
writable. If, on the other hand, the device is not able to accept any more data,
write returns -ENOSPC (“No space left on device”), independently of the setting of
O_NONBLOCK .

• Never make a write call wait for data transmission before returning, even if
O_NONBLOCK is clear. This is because many applications use select to find out
whether a write will block. If the device is reported as writable, the call must not
block. If the program using the device wants to ensure that the data it enqueues
in the output buffer is actually transmitted, the driver must provide an fsync
method. For instance, a removable device should have an fsync entry point.

--------------------------------------------------------------------------------
Flushing pending output
--------------------------------------------------------------------------------
Prototype:
int (*fsync) (struct file *file, struct dentry *dentry, int datasync);

If some application ever needs to be assured that data has been sent to the
device, the fsync method must be implemented regardless of whether O_NONBLOCK is
set. A call to fsync should return only when the device has been completely
flushed (i.e., the output buffer is empty), even if that takes some time.

The fsync method has no unusual features. The call isn’t time critical, so every
device driver can implement it to the author’s taste. Most of the time, char
drivers just have a NULL pointer in their fops . Block devices, on the other
hand, always implement the method with the general-purpose block_fsync, which,
in turn, flushes all the blocks of the device, waiting for I/O to complete.

