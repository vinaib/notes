--------------------------------------------------------------------------------
Bootloader performs below tasks:
Sources: 
http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html
https://www.slax.org/blog/18432-initrd-versus-initramfs.html
https://stackoverflow.com/questions/10603104/the-difference-between-initrd-and-initramfs.
https://elinux.org/images/f/f9/Petazzoni-device-tree-dummies_0.pdf
--------------------------------------------------------------------------------
1. Setup and initialise the RAM.  linux/Documentation/kernel-parameters.txt
--------------------------------------------------------------------------------
1) The boot loader is expected to find and initialise all RAM that the
kernel will use for volatile data storage in the system.  It performs
this in a machine dependent manner.

2) In all cases it should be noted that all setup is performed by the
bootloader. The kernel should have no knowledge of the setup or configuration of
the RAM within a system other than that provided by the bootloader.

3) The physical memory layout is passed to the kernel using the ATAG_MEM
parameter. Memory does not necessarily have to be completely contiguous,
although the minimum number of fragments is preferred. Multiple ATAG_MEM
blocks allow for several memory regions. The kernel will coalesce blocks
passed to it if they are contiguous physical regions.

4) The bootloader may also manipulate the memory with the kernels command line,
using the 'mem=' parameter, the options for this parameter are fully
documented in linux/Documentation/kernel-parameters.txt.

5) The kernel command line 'mem=' has the syntax mem=<size>[KM][,@<phys_offset>]
which allows the size and physical memory location for a memory area to be
defined. This allows for specifying multiple discontigous memory blocks at
differing offsets by providing the mem= parameter multiple times.

--------------------------------------------------------------------------------
2. Loading the kernel image
offset: 0x8000
--------------------------------------------------------------------------------
1) Kernel images generated by the kernel build process are either uncompressed
"Image" files or compressed zImage files.

2) The uncompressed Image files are generally not used, as they do not contain a
readily identifiable magic number. The compressed zImage format is almost
universally used in preference.

TODO: What magic number do they contain?

3) Typically, the decompression of the image is faster than reading from some
external media.

4) The integrity of the image can be assured, as any errors will result in a
failed decompress.

--------------------------------------------------------------------------------
Offset into zImage  | Value			| Description
--------------------------------------------------------------------------------
0x24				| 0x016F2818	| Magic number used to identify this is an
					|				| ARM Linux zImage
--------------------------------------------------------------------------------
0x28				| start address	| The address the zImage starts at
--------------------------------------------------------------------------------
0x2C				| end address	| The address the zImage ends at
--------------------------------------------------------------------------------

5) the maximum uncompressed kernel size is 4MB. This is a hard limit and would
include the initrd if a bootpImage target was used.

6) Although the zImage may be located anywhere, care should be taken. Starting a
compressed kernel requires additional memory for the image to be uncompressed
into. This space has certain constraints.
a) The zImage decompression code will ensure it is not going to overwrite the
compressed data
b) If the kernel detects such a conflict it will uncompress the image
immediately after the compressed zImage data and relocate the kernel after
decompression.
c)the memory region the zImage is loaded into must have up to 4Megabytes of
space after it.

7) Despite the ability to place zImage anywhere within memory, convention has it
that it is loaded at the base of physical RAM plus an offset of 0x8000 (32K).
This leaves space for the parameter block usually placed at offset 0x100, zero
page exception vectors and page tables. This convention is very common.
--------------------------------------------------------------------------------
3. Detect the machine type.
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
4. Setup the kernel tagged list.
offset: first 16KiB of RAM
--------------------------------------------------------------------------------
1) The bootloader must pass parameters to the kernel to describe the setup it
has performed, the size and shape of memory in the system and, optionally,
numerous other values.

2) The list must be stored in RAM and placed in a region of memory where neither
the kernel decompresser nor initrd manipulation will overwrite it. The
recommended placement is in the first 16KiB of RAM, usually the start of
physical RAM plus 0x100 (which avoids zero page exception vectors).

3) The physical address of the tagged list must be placed in R2 on entry to the
kernel.

4) The list must not extend past the 0x4000 boundary where the kernel's initial
translation page table is created. The kernel performs no bounds checking and
will overwrite the parameter list if it does so.

5) The list must be aligned to a word

6) The list must begin with an ATAG_CORE and end with ATAG_NONE

7) The list must contain at least one ATAG_MEM
--------------------------------------------------------------------------------
5. Load Initrd. what is Initramfs?: linux/Documentation/initrd.txt
offset: 8MB from base of physical memory
--------------------------------------------------------------------------------
1) It provides a way to have a root filesystem.

2) There are two methods available on ARM Linux to obtain an initial RAM disk
a) The first is a special build target bootpImage which takes an initial RAM
disk at build time and appends it to a zImage.
  This method has the benefit that it needs no bootloader intervention, but
requires the kernel build process to have knowledge of the physical address to
place the ramdisk (using the INITRD_PHYS definition). The hard size limit for
the uncompressed kernel and initrd of 4Megabytes applies. Because of these
limitations this target is rarely used in practice.
b) The second and much more widely used method is for the bootloader to place a
given initial ramdisk image, obtained from whatever media, into memory at a set
location. This location is passed to the kernel using ATAG_INITRD2 and
ATAG_RAMDISK.
Conventionally the initrd is placed 8Megabytes from the base of physical memory.
Wherever it is placed there must be sufficient memory after boot to decompress
the initial ramdisk into a real ramdisk i.e. enough memory for zImage +
decompressed zImage + initrd + uncompressed ramdisk.

 The compressed initial ramdisk memory will be freed after the decompression has
happened.

3) Limitations to the position of the ramdisk are:
a) It must lie completely within a single memory region (must not cross between
areas defined by different ATAG_MEM parameters).
b) It must be aligned to a page boundary (typically 4k)
c) It must not conflict with the memory the zImage head code uses to decompress
the kernel or it will be overwritten as no checking is performed.

4) Initrd/ramdisk is a fixed-size block device, which requires to be 'formatted' 
by a filesystem such as ext2. It sits on /dev/ram0 by default, and cannot be 
enlarged or shortened.
a)Linux is designed to cache all files and directory entries read from or 
written to block devices, so Linux copies data to and from the ramdisk into the
"page cache" (for file data), and the "dentry cache" (for directory entries).
b) The initrd file is read and unzipped into the device, as if you did zcat
initrd | dd of=/dev/ram0 or something similar.
c)The initrd contains an image of a filesystem, so now you can mount the
filesystem as usual: mount /dev/ram0 /root. Naturally, filesystems need a
driver, so if you use ext2, the ext2 driver has to be compiled in-kernel.


5) On the other hand, initramfs is a cpio archive which is simply unpacked
during boot to ramfs memory. This memory is of dynamic size and thus can be
shortened or enlarged as needed.
a) It evolved around the idea, what if Linux's cache could be mounted like a
filesystem? These ram based filesystems automatically grow or shrink to fit the
size of the data they contain. Adding files to a ramfs (or extending existing
files) automatically allocates more memory, and deleting or truncatingfiles 
frees that memory.
b) A tmpfs is mounted: mount -t tmpfs nodev /root. The tmpfs doesn't need a
driver, it is always on-kernel. No device needed, no additional drivers.
c) The initramfs is uncompressed directly into this new filesystem: zcat
initramfs | cpio -i, or similar.


--------------------------------------------------------------------------------
6. Initialising kernel: linux/Documentation/kernel-parameters.txt
--------------------------------------------------------------------------------
1) The bootloader should initialise and enable one serial port on the
target.This includes enabling any hardware power management etc., to use the
port.

2) This allows the kernel serial driver to automatically detect which serial
port it should use for the kernel console.

3) the bootloader can pass the relevant 'console=' option to the kernel, via the
command line parameter specifying the port, and serial format options as
described in linux/Documentation/kernel-parameters.txt.

--------------------------------------------------------------------------------
7. bootargs: passing through uboot vs passing through DTB
--------------------------------------------------------------------------------
a) bootargs in devicetree:
-> chosen node is used to send boot arguments to the kernel
example:
chosen {
        bootargs = "console=ttyO0,115200 root=/dev/mmcblk0p2 rootfstype=ext3 rw rootwait";
        stdout-path = &uart0;
    };
b) bootargs through uboot command line
bootargs= console=ttyO0,115200 ip=10.0.0.111:10.0.0.4::255.255. 255.0 rw
root=/dev/nfs nfsroot=10.0.0.4:/home/user/beaglebone/rootfs

if same parameter is set in the device tree and in the atags (uboot), the one
from the uboot tags will be chosen.


